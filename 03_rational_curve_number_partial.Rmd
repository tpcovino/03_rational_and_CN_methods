---
author: "YOUR NAME HERE"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
---

# Rational method and NRCS curve number (20 pts)

## Codework

In this module, you will apply the Rational Method and the SCS curve number (CN) method to estimate peak flows and effective rainfall/runoff volumes. This lab also reviews two coding techniques; for-loops and functions.

This is knitr settings. Knitr is a package that will turn this Rmd to an html. 
```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, results = FALSE)
```

### Packages - our first function for this module

Instead of installing libraries one at a time, let's write a function that takes a list of packages, checks if they are installed, installs them from CRAN if needed and then loads them into the project with library().

```{r setup, include=FALSE}
pkgTest <- function(x) # name the function, it will have one argument, x. 
{
  if (x %in% rownames(installed.packages()) == FALSE) { # if the package name is not installed...
    install.packages(x, dependencies= TRUE) # install it
  }
  library(x, character.only = TRUE) # then load each needed package with library().
}

# Make a vector of the packages you need
neededPackages <- c('tidyverse', 'broom', 'progress', 'tictoc') 

# For every package in the vector, apply your pkgTest function
for (package in neededPackages){pkgTest(package)}

# tictoc times the execution of different modeling methods
# progress will provide progress bars for functions
# broom wil convert messy, non-standard output of built-in statistical functions and convert them into tidy tibbles (data frames)
```

### Part I - Rational Method

The Rational Method is a simple approach for estimating peak runoff from a small watershed using rainfall intensity, watershed area, and a runoff coefficient. It assumes peak discharge occurs when rainfall intensity is applied uniformly over a duration equal to the watershed time of concentration.

The goal of the following workflow is to calculate peak runoff (cfs) for a small 280-acre rangeland watershed near Bozeman for multiple precipitation events with different return intervals. You will first have to calculate the 
1. time of concentration and then 
2. look up the the rainfall values for the different return intervals. 

--The longest flowpath in the watershed is 6300 ft long. 
--average watershed slope is 1.95%. 

#### Time of Concentration

- Time of concentration is the time it takes water to travel along the longest flowpath in the watershed and exit the watershed. 

```{r Time_of_Concentration}
A <- BLANK # Area in acres
L <- BLANK # Longest flowpath length (ft)
S <- BLANK# Slope (ft/ft)

tc <- 0.0078 * L^0.77 * S^-0.385 # Kirpich concentration time
tc
```

The time of concentration (tc) in this example should be ~ 29.91. If your calculated value is very different, start by checking slope value (S). For the sake of simplicity in next steps, do not change the name of variables.

#### Storm Depths
Now that you have the time of concentration, you can move to the second step of the workflow: selecting rainfall values for different return intervals. The Rational Method assumes rainfall is represented as an average intensity for a storm duration approximately equal to the time of concentration (tc). This ensures that the entire watershed is contributing flow when peak discharge occurs.

Your tc is approximately 30 minutes, so you would ideally use rainfall intensities for a storm of similar duration. Because sub-hourly rainfall frequency data are not provided here, you will approximate the required intensities using 1-hour storm depths for Bozeman, MT.

You are provided with daily precipitation depths for several return intervals (1, 2, 5, 10, 25, 50, and 100 years). For the purposes of this assignment, assume that the 1-hour depth can be approximated by dividing the daily depth by 24. While this is a simplification and not physically realistic for design work, it is sufficient for illustrating this Method

```{r Storm_Depths}
#Create a data frame called storms with the following columns:
#Tr: return period (years)
#Pin: daily storm depth (inches)
#Pin_hr: average 1-hour storm intensity (inches/hour), calculated as Pin / 24
#You will use Pin_hr as the rainfall intensity input in the Rational Method calculations that follow.

storms <- tibble(
  Tr = c(BLANK), # vector of return intervals in years 
  Pday = c(1.0, 1.18, 1.75, 2.10, 2.50, 2.81), # column for storm depth
  Pin_hr = Pday / 24) # storm depth converted to an intensity of inches per hour 
```

#### Example for-loop
Now that we have the rainfall intensities, we need to set up a way that calculates peak discharge (Qp) for each of those intensities, without us having to go back and manually enter them each time. We do this with a for-loop. Let's first look at how for loops work in R. 

A for-loop will execute the code inside it for a specified number of iterations. The structure looks like:

for(i in some number of iterations) {
  output <- some code, function or equation that needs to be executed
  } 
  
In the chunk below, we create the vector x, which contains 6 values (0, 2, 4, 6, 8, 10). Each loop then executes a calculation using each value in 'x' in sequence. 

In a for-loop, 'i' is called the loop index or iterator. It has a new value in each iteration of the loop. You can think of i as a 'counter' that helps the loop keep track of its progress. In the example below, we want to run the code in the loop for every value in the vector 'x'. Since there are 6 values in vector 'x', then we will tell the loop to run 6 times. However, rather than for (i in 1:6), using 1:length(x) ensures the loop adapts to the size of x, no matter how many values it contains. This improves the flexibility of our code.

We also need to store the output of loop during each iteration. If we don't store the results of each iteration or loop, the loop will overwrite the output each time, leaving us with only the result from the final iteration. To store the output of each loop iteration, we have to preallocate a vector (like y) to store all of the outputs. In other words, we are creating an empty vector with the same length as 'x' for the for-loop to add values to.

Let's try a simple example first: 
```{r Loop_Example}
x <- seq(0, 10, 2) # create vector from 0 to 10 in increments of 2

y <- vector(mode = "double", length(x)) # preallocate y vector with length of x

# run the for loop
for (i in 1:length(x)) { # loop through i 
  y[i] <- x[i]^2 # calculation
}
# check the results
y
```

We have created a vector x from 0 to 10 in increments of 2. The for-loop takes each element of that vector and squares it. The "i" is called an index and runs from 1 through 6 (the length of x). During the first iteration i is 1, during the second iteration i is 2, and so on. We are then writing the results from the calculation into a new vector, y. When i is 1, we are squaring the first value in vector x, which is 0. The first value in y will be zero as well. When i is 2, the second value in x gets squared, which is 2^2. The second value in y is going to be 4.

#### Calculate Qp with for-loop
Now let's set up the for-loop for the Rational Method. We need to set up a for-loop that does the same calculation 7 times, the number of precip values in "storms". 

Note that above, we used length() of a vector to determine the number of iterations in our loop. However, 'length()'for a dataframe returns the number of columns, so now that we are working in a dataframe instead of a vector, we want to use 'nrow()', which will count the number of dataframe rows. 

The calculated peak discharges should go into a new column of our "storms" df. However, indexing is slow for dataframes, so we will write the new values into a new vector, Qp, and then after the loop insert the vector as a column into the dataframe.
--Check out the table link in the reading/text to select C.
**If you are using the complete version of the assignment, do not assume that this C value is correct**

```{r Rational_Loop}
# DEFINE C
C <- BLANK # runoff coefficient

# preallocate vector (think about what the length needs to be and how to get it without just typing in the number)
Qp <- vector(mode = "double", nrow(storms)) # mode = 'double' here helps create a numeric vector to store decimal values rather than integers.

for (i in 1:nrow(BLANK # check parenthesis and brackets too.
  # the actual Rational Method calculation. For the precip, you need to use the column in the storms df that has the one hour precip intensities 
  Qp[i] <- C * A * storms$Pin_hr[i]
}

# Now that the for-loop is done, this adds the new peakflows to the existing "storms" df as a column
storms <- storms %>%
  mutate(Qp = Qp)

# FULL DISCLAIMER
# We could have accomplished the same with vectorization. 
# As a rule of thumb, you should try to avoid for-loops with working with a lot of iterations or complex calculations, but we'll discuss this more in later lessons. However, for-loops are valuable for their versatility, making them an excellent tool for iterating over data and building fundamental programming skills.

Qp_vectorized <- C*A*storms$Pin_hr
Qp_vectorized
```

#### Plot Tr and Qp
Now plot the return interval against the storm peakflow. You only need three to four lines for this: 1st sets up the data, 2nd defines the theme that removes the gray background and sets the axes labels to a proper size, 3rd plots the data with geom_points, 4th makes the axes labels with labs. Note that axis labels have units. This is an important feature when communicating your findings.

```{r}
ggplot(storms, aes(x = Tr, y = Qp)) +
  theme_bw(base_size = BLANK) +
  BLANK
  BLANK(x = "Return Period (Years)", y = "Peakflow (cfs)")
```

**1. (1 pt) What does the C in the Rational Method do?**  
ANSWER: 

**2.(2 pts) For a watershed being analyzed with the Rational Method, explain what the time of concentration represents physically. Describe how an incorrect estimate of time of concentration would affect peak discharge.**
ANSWER: 


### Part II - NRCS CN
In Part I, you used the Rational Method to estimate peak discharge from a watershed during a storm event. In this section, we shift focus to a different hydrologic question: How much runoff volume is generated from a rainfall event. Recall that peak discharge describes *how fast* water leaves a watershed at its maximum rate, whereas runoff volume describes *how much* water leaves the watershed over the course of a storm. 

The NRCS Curve Number (CN) method estimates runoff volume based on rainfall depth, watershed characteristics, and antecedent moisture conditions.

In this exercise, you will write a function that calculates runoff depth using the NRCS CN method. The function will require precipitation depth (P), curve number (CN), and antecedent moisture condition (AMC) as inputs and will return runoff depth (Q). This function will not automatically determine CN values; you will still need to select appropriate CN values based on land use and soil conditions.

#### Writing a function 
Let’s look at a simple example of writing a function. Suppose we want a function that raises a number to a power, where both the base and the exponent are chosen by the user.

In R, a function is created using function().
-The values the function needs as input are listed inside the parentheses ().
-The instructions for what the function does are written inside the curly braces {}.
-The result we want the function to give back is returned using return().

```{r}
rundatfunction <- function(base, exponent) {
  new_number <- base^exponent

  return(new_number)
}
```

Run  the above function. You will notice that a function was added to the Global Environment (top right panel Rstudio) all the way at the bottom. Now let's test the function with a base of 2 and an exponent of 3. This should perform the calculation 2x2x2 = 8

```{r}
rundatfunction(2, 3)
```

#### NRCS CN test
Before we write a new function to estimate Q using CN, let's make sure we can set up the correct steps WITHOUT the function. This is almost always a helpful step in developing functions. It can save hours of headaches later. Let's try P = 2.5 inches, CN = 90, and AMC = 3.
The biggest hurdle here is going to be creating a lookup table for the AMC. I will provide the basic structure of the code for this.

```{r}
P <- 2.5 # 50-year, 24-hour rainfall (in.), from TP40
CN <- 90
AMC <- 3

### Adjust for antecedent moisture (AMC)
# use the equations from the lecture to adjust the CN to dry or wet conditions if necessary
# AMC I
if (AMC == 1) {
  CN_adj <- (4.2 * CN) / (10 + 0.058 * CN)
}

# AMC II The curve number remains whatever the input is.
if (AMC == 2) {
  CN_adj <- CN
}

# AMC III
if (AMC == 3) {
  CN_adj <- (23 * CN) / (10 + 0.13 * CN)
}

# calculate Si
Si <- 1000 / CN_adj - 10 # Storage part

# estimate initial abstraction parameter
# initial abstraction is the portion of rainfall that gets “soaked up” or fills puddles before any runoff can occur.
Ia <- 0.2 * Si

# Check equation from lecture
# calculate Q
Q <- (P - 0.2 * Si)^2 / (P + BLANK * Si) # SCS CN runoff (inches)
Q
```
Sanity check: Q should ~ 2.0 for the specified parameters.

**3.(4 pt) What is one of the critical assumptions for the SCS CN method? (1-2 sentences). Why is it important to understand assumptions of models like this one?**  
ANSWER:

Now write a function called "scs_cn" that takes the inputs P, CN, and AMC (all numeric) and returns Q, Ia, Si, and the RR as a dataframe called "scs_out".

```{r SCS_CN}
scs_cn <- function(BLANK) { # note in our first function example, we put variable names here, not numerical values

  ### Adjust for AMC
  # AMC I
  if (AMC == 1) {
    CN_adj <- BLANK
  }
  
  # AMC II
  if (AMC == 2) {
    CN_adj <- CN
  }
  
  # AMC III
  if (AMC == 3) {
    CN_adj <- (23 * CN) / (10 + 0.13 * CN)
  }

# Check equation from lecture
  # calculate S
  S <- BLANK # Storage part

  # estimate initial abstraction
  Ia <- BLANK

  Q <- (P - 0.2 * S)^2 / (P + 0.8 * S) # SCS CN runoff (inches)
  
  # statement that spits out a warning if the initial abstraction is greater than the precipitation amount
  if (Ia > P) {
    warning("Ia is greater than P. Resulting Q is 0.")
  }

  scs_out <- tibble(Si, Ia, Q, P, RR = Q / P)
  return(scs_out)
}
```

Great! Notice that running this chunk does not produce any numerical output. Instead, we have packaged the entire Curve Number workflow into a function called scs_cn. This function defines the steps needed to calculate runoff, but it does not perform a calculation until we supply actual input values for precipitation, curve number, and antecedent moisture condition. Once defined, the function allows us to repeat the same calculation many times with different inputs, while ensuring the equations and assumptions are applied consistently.

Test the function for P = 2.5 in, CN = 90, AMC = 3.
```{r SCS_CN}
# TEST THE FUNCTION with P = 2.5, CN = 90, and AMC = 3
SCS_example <- scs_cn(P=BLANK, CN = BLANK, AMC =BLANK)
SCS_example
```

OK, you so now you have used the NRCS Curve Number method to estimate runoff depth and runoff ratio for a single storm event. Unlike the Rational Method, which estimates peak discharge, the CN method estimates how much rainfall becomes runoff, making it more directly tied to infiltration, soil storage, and watershed wetness. By writing the calculation as a function, you also made the model repeatable and easy to apply across many storms or parameter combinations.

It is important to remember that the CN method is a lumped approach that relies on strong assumptions about rainfall uniformity, soil behavior, and initial abstraction. Therefore, CN-based estimates are most useful for comparative analysis and planning-level assessments. In this lab, we utilized this method primarily to demonstrate how model parameters and assumptions control model output (runoff generation in this case), rather than to produce a precise prediction for a specific event.

**4.(3 pts) Describe what factors into the curve number (and most notably what is missing). What does it mean when the CN is 100 or 0?**  
ANSWER: 

**5.(4 pts) Suppose you run the same watershed runoff model twice using identical rainfall and watershed characteristics.(a) Describe what the runoff results would look like if the model is deterministic. Why? (b) Describe what the runoff results would look like if the model is stochastic. Why?**   
ANSWER:

**6. (2 pts) Are the Rational Method and CN calculation stochastic or deterministic?**
ANSWER:

**7. (4. pts)(4-6 sentences) Let's consider the cross-disciplinary relevance of hydrological modeling. You may not be studying hydrology directly, but environmental resource managers often need to estimate peak flows. Why? (1-2 sentences). In a sentence, what is your specific area of interest, or the topic of your professional paper, if known. Consider broader implications of the hydrologic cycle, like water quality, nutrient or pollution transport, or erosion. Does rainfall/runoff management affect your niche? If so, how? (2-4 sentences)**
ANSWER:
